# 操作系统

## 什么是操作系统

### 控制角度

1. 用户角度上，操作系统是一个控制软件
2. 管理应用程序
3. 为应用程序提供服务
4. 杀死应用程序

### 资源分配角度

1. 资源管理

2. 管理外设，分配资源

   ![image-20211113184749489](C:\Users\wallen\AppData\Roaming\Typora\typora-user-images\image-20211113184749489.png)

### 操作系统架层次结构

1. 硬件之上
2. 应用程序之下

### 软件层面

1. 应用软件：办公软件、视频播放软件
2. 操作系统位于应用软件之下，为应用软件提供服务支撑
3. Linux、Windows、Android的界面属于外壳（Shell），而不是内核（Kernel），Kernel在Shell之下。

### Kernel操作系统内部组件，包括

1. CPU调度器
2. 物理内存管理
3. 虚拟内存管理
4. 文件系统管理
5. 中断处理与设备驱动

### OS Kernel的特征

1. 并发
   1. 计算机系统中同时存在多个运行的程序，需要OS管理和调度
2. 共享
   1. “同时”访问
   2. 互斥共享
3. 虚拟
   1. 利用多道程序设计技术，让每个用户都觉得有一个计算机专门为他服务
4. 异步
   1. 程序的执行不是一贯到底，而是走走停停，向前推进的速度不可预知
   2. 但只要运行环境相同，OS需要保证程序运行的结构也要相同

### 操作系统需要权衡

1. 空间与时间
2. 性能和可预测性
3. 公平和性能

### 硬件方面，操作系统需要

1. 良好的硬件管理
2. 合理的资源分配
3. 例如：硬盘速度跟CPU、内存相差很多，操作系统需要协调处理

## 操作系统结构

- 简单操作系统：MS-DOS（1981-1994）
- 不分模块的单体内核
- 微内核的设计，尽可能把内核功能移动到用户空间
- 学术界存在另一种更加极端的架构，“外核”

## 操作系统的启动

1. DISK：存放OS
2. BIOS：基本I/O处理系统
3. Bootloader：加载OS
4. CS：IP = 0xf000:fff0 （CS：段寄存器，IP：指令寄存器）POST(加电自检)，寻找显卡和执行BIOS
5. BIOS
   1. 将Bootloader从磁盘的引导扇区（512字节）加载到0x7c00
   2. 跳转到CS：IP = 0000：7c00
6. Bootloader
   1. 将操作系统的代码和数据从硬盘加载到内存
   2. 跳转到操作系统的起始地址

### 操作系统与设备和程序交互

1. 系统调用
   1. 应用程序主动向操作系统发出服务请求
2. 异常
   1. 非法指令或者其他坏的处理状态（如：内存出错）
3. 中断
   1. 来自不同的硬件设备的计时器和网络的中断
4. 在计算机运行中，内核是被信任的第三方
5. 只有内核可以执行特权指令
6. 为了方便应用程序

#### 系统调用、异常和中断的特点

1. 源头
   1. 中断：外设
   2. 异常：应用程序意想不到的行为
   3. 系统调用：应用程序请求操作提供服务
2. 处理时间
   1. 中断：异步
   2. 异常：同步
   3. 系统调用：异步或同步
3. 响应
   1. 中断：持续，对用户应用程序是透明的
   2. 异常：杀手或者重新执行意想不到的应用程序指令
   3. 系统调用：等待和持续

#### 中断和异常的处理机制

1. 中断是外设的事件
2. 异常是内核CPU的事件
3. 中断和异常迫使CPU访问一些被中断和异常服务访问的功能

##### 中断

###### 硬件

1. 设置中断标记【CPU初始化】
   1. 将内部、外部事件设置中断标记
   2. 中断事件的ID

###### 软件

1. 保存当前处理状态
2. 中断服务程序处理
3. 清楚中断标记
4. 恢复之前保存的处理状态

##### 异常

1. 异常编号
2. 异常处理
   1. 杀死产生异常的程序
   2. 重新执行异常指令
3. 恢复现场

##### 系统调用

1. 程序访问主要通过高层次的API接口而不是直接进行系统调用
2. 通常情况下，与每个系统调用相关的序号
   1. 系统调用接口根据这些编号来维护表的索引
3. 系统调用接口调用内核态中预期的系统调用
   1. 并返回系统调用的状态和其他任何返回值
4. 用户不需要知道系统调用怎么实现
   1. 只需要获取API和了解操作新系统将什么作为返回结果
   2. 操作系统接口的细节大部分都隐藏在API中
      1. 通过运行程序支持的库来管理（用包含编译器的库来创建函数集）

#### 跨越操作系统边界的开销

1. 在执行时间上的开销超过程序调用
2. 开销
   1. 建立中断/异常/系统调用号与对应服务例程映射关系的初始化开销
   2. 建立内核堆栈
   3. 验证参数
   4. 内核态映射到用户态的地址空间，更新页面映射权限
   5. 内核态独立地址空间，TLB
